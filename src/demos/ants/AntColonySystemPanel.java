/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * AntSystemPanel.java
 *
 * Created on Mar 21, 2010, 3:23:33 PM
 */
package demos.ants;

import libai.common.Matrix;
import libai.ants.algorithms.AntColonySystem;
import libai.common.Graph;
import libai.ants.Node;
import libai.ants.Enviroment;
import java.util.*;

/**
 *
 * @author kronenthaler
 */
public class AntColonySystemPanel extends javax.swing.JPanel {
    /**
     * Creates new form AntSystemPanel
     */
    public AntColonySystemPanel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jScrollPane2 = new javax.swing.JScrollPane();
        answerTxt = new javax.swing.JTextArea();
        jButton3 = new javax.swing.JButton();
        jProgressBar1 = new javax.swing.JProgressBar();
        parameterSet = new javax.swing.JComboBox();

        jTextArea1.setColumns(20);
        jTextArea1.setEditable(false);
        jTextArea1.setLineWrap(true);
        jTextArea1.setRows(5);
        jTextArea1.setText("To find the shortest path between the nest and the source of food, the ants uses an enviromental type of comunication as known as stirmergy. The framework that implements the ants colony algorithms is very generic and precise some particular functions to be implemented by the user based on the condition of the problem (like in the search algorithms). In this example we have a graph of 5 nodes, simulating the double-brigde problem.\nThe next adjacency matrix defines the graph.\n   0 1 2 3 4 \n0 0 1 2 0 0\n1 1 0 0 1 0\n2 2 0 0 2 0\n3 0 1 2 0 1\n4 0 0 0 1 0");
        jScrollPane1.setViewportView(jTextArea1);

        answerTxt.setColumns(20);
        answerTxt.setRows(5);
        jScrollPane2.setViewportView(answerTxt);

        jButton3.setText("Search");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jProgressBar1.setString("training");
        jProgressBar1.setStringPainted(true);

        parameterSet.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Parameter set 1", "Parameter set 2", "Parameter set 3", "Parameter set 4", " " }));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(parameterSet, 0, 360, Short.MAX_VALUE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 360, Short.MAX_VALUE)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 360, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jProgressBar1, javax.swing.GroupLayout.DEFAULT_SIZE, 271, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton3)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 183, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.DEFAULT_SIZE, 65, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(parameterSet, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButton3)
                    .addComponent(jProgressBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

	private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        try {
            final SP_ACS as = new SP_ACS(0, 4, parameterSet.getSelectedIndex());

            jProgressBar1.setMinimum(0);
            jProgressBar1.setMaximum((int) as.getParam(2));
            jProgressBar1.setValue(0);

            new Thread(new Runnable() {
                public void run() {
                    while (as.getCurrentIterationNumber() < jProgressBar1.getMaximum()) {
                        jProgressBar1.setValue(as.getCurrentIterationNumber());
                        try {
                            Thread.sleep(1);
                        } catch (Exception e) {
                        }
                    }
                    jProgressBar1.setValue(jProgressBar1.getMaximum());
                }
            }).start();

            as.solve();

            answerTxt.append(as.getBestSolution().toString() + " F(x)=" + as.f(as.getBestSolution()));
            answerTxt.append("\n");
        } catch (Exception e) {
            e.printStackTrace();
        }
}//GEN-LAST:event_jButton3ActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTextArea answerTxt;
    private javax.swing.JButton jButton3;
    private javax.swing.JProgressBar jProgressBar1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JComboBox parameterSet;
    // End of variables declaration//GEN-END:variables

    static class SP_ACS extends AntColonySystem {
        public SP_ACS() {
        }

        public SP_ACS(Enviroment E) {
            super(E);
        }

        public SP_ACS(int problemInitialNode, int problemDestinationNode, int parametersSet) throws Exception {
            Graph G = new Graph(5, 5, new double[]{0, 1, 2, 0, 0,
                0, 0, 0, 1, 0,
                0, 0, 0, 2, 0,
                0, 0, 0, 0, 1,
                0, 0, 0, 0, 0});
            /* Set enviroment */
            Enviroment Env = new Enviroment(G /* Graph */, true /* random pheromone trail */);
            this.setParam(SP_ACS.initialNode, problemInitialNode);
            this.setParam(SP_ACS.destinationNode, problemDestinationNode);
            switch (parametersSet) {
                case 0:
                    this.setParam(SP_ACS.maxNumIterations, 5);
                    this.setParam(SP_ACS.beta, 0.25);
                    this.setParam(SP_ACS.maxCandidates, 50);
                    this.setParam(SP_ACS.r_0, 0.5);
                    this.setParam(SP_ACS.ro_1, 0.1);
                    this.setParam(SP_ACS.ro_2, 0.9);
                    this.setParam(SP_ACS.tau_0, 0.1);
                    Env.setAnts(5);
                    break;
                case 1:
                    this.setParam(SP_ACS.maxNumIterations, 50);
                    this.setParam(SP_ACS.beta, 1);
                    this.setParam(SP_ACS.maxCandidates, 50);
                    this.setParam(SP_ACS.r_0, 0.4);
                    this.setParam(SP_ACS.ro_1, 0.1);
                    this.setParam(SP_ACS.ro_2, 0.9);
                    this.setParam(SP_ACS.tau_0, 0.1);
                    Env.setAnts(5);
                    break;
                case 2:
                    this.setParam(SP_ACS.maxNumIterations, 100);
                    this.setParam(SP_ACS.beta, 0.8);
                    this.setParam(SP_ACS.maxCandidates, Integer.MAX_VALUE);
                    this.setParam(SP_ACS.r_0, 0.8);
                    this.setParam(SP_ACS.ro_1, 0.25);
                    this.setParam(SP_ACS.ro_2, 0.9);
                    this.setParam(SP_ACS.tau_0, 0.1);
                    Env.setAnts(10);
                    break;
                case 3:
                    this.setParam(SP_ACS.maxNumIterations, 200);
                    this.setParam(SP_ACS.beta, 0.5);
                    this.setParam(SP_ACS.maxCandidates, 50);
                    this.setParam(SP_ACS.r_0, 0.5);
                    this.setParam(SP_ACS.ro_1, 0.1);
                    this.setParam(SP_ACS.ro_2, 0.9);
                    this.setParam(SP_ACS.tau_0, 0.1);
                    Env.setAnts(15);
                    break;
            }
            /* set enviroment*/
            this.setE(Env);
        }

        public Vector<Integer> constrains(int i, Vector<Integer> currentSolution) {
            int cols = this.Graph.getM().getColumns();
            Vector<Integer> adjacents = new Vector<Integer>();
            //Calculate adjancent nodes
            for (int j = 0; j < cols; j++) {
                if (this.Graph.getM().position(i, j) < Integer.MAX_VALUE) {
                    //Is adyacent
                    adjacents.add(j);
                }
            }
            return adjacents;
        }

        public void candidateList(int max) {
            Matrix G = this.Graph.getM();
            int rows = G.getRows(), cols = G.getColumns(), cont;

            for (int i = 0; i < rows; i++) {
                cont = 0;
                Vector<Node> nodes = new Vector<Node>();
                for (int j = 0; j < cols; j++) {
                    if ((G.position(i, j) < Integer.MAX_VALUE)) {
                        Node nodeTmp = new Node(j, G.position(i, j), 1 / G.position(i, j));
                        nodes.add(nodeTmp);
                    }
                }
                /* Order candidates */
                Collections.sort(nodes);
                /* Truncate vector by max candidates parameter */
                if (nodes.size() > max) {
                    nodes.setSize(max);
                }
                /* Add this node i candidates */
                this.candidates.put(i, nodes);
            }
        }

        public double heuristicInfo(double number) {
            return 1.0 / number;
        }

        @Override
        public double f(Vector<Integer> Solution) {
            int numberSolutionNodes = Solution.size();
            if (numberSolutionNodes != 0 && Solution.elementAt((numberSolutionNodes - 1)) != this.Parameters.get(AntColonySystem.destinationNode).intValue()) {
                return Double.MAX_VALUE;
            } else {
                return super.f(Solution);
            }
        }
    }
}
